// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	"go.temporal.io/sdk/internal"
)

// NewWorkflowInboundInterceptor creates a new instance of WorkflowInboundInterceptor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkflowInboundInterceptor(t interface {
	mock.TestingT
	Cleanup(func())
}) *WorkflowInboundInterceptor {
	mock := &WorkflowInboundInterceptor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WorkflowInboundInterceptor is an autogenerated mock type for the WorkflowInboundInterceptor type
type WorkflowInboundInterceptor struct {
	mock.Mock
}

type WorkflowInboundInterceptor_Expecter struct {
	mock *mock.Mock
}

func (_m *WorkflowInboundInterceptor) EXPECT() *WorkflowInboundInterceptor_Expecter {
	return &WorkflowInboundInterceptor_Expecter{mock: &_m.Mock}
}

// ExecuteUpdate provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) ExecuteUpdate(ctx internal.Context, in *internal.UpdateInput) (interface{}, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteUpdate")
	}

	var r0 interface{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.UpdateInput) (interface{}, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.UpdateInput) interface{}); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func(internal.Context, *internal.UpdateInput) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowInboundInterceptor_ExecuteUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteUpdate'
type WorkflowInboundInterceptor_ExecuteUpdate_Call struct {
	*mock.Call
}

// ExecuteUpdate is a helper method to define mock.On call
//   - ctx internal.Context
//   - in *internal.UpdateInput
func (_e *WorkflowInboundInterceptor_Expecter) ExecuteUpdate(ctx interface{}, in interface{}) *WorkflowInboundInterceptor_ExecuteUpdate_Call {
	return &WorkflowInboundInterceptor_ExecuteUpdate_Call{Call: _e.mock.On("ExecuteUpdate", ctx, in)}
}

func (_c *WorkflowInboundInterceptor_ExecuteUpdate_Call) Run(run func(ctx internal.Context, in *internal.UpdateInput)) *WorkflowInboundInterceptor_ExecuteUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 *internal.UpdateInput
		if args[1] != nil {
			arg1 = args[1].(*internal.UpdateInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_ExecuteUpdate_Call) Return(ifaceVal interface{}, err error) *WorkflowInboundInterceptor_ExecuteUpdate_Call {
	_c.Call.Return(ifaceVal, err)
	return _c
}

func (_c *WorkflowInboundInterceptor_ExecuteUpdate_Call) RunAndReturn(run func(ctx internal.Context, in *internal.UpdateInput) (interface{}, error)) *WorkflowInboundInterceptor_ExecuteUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteWorkflow provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) ExecuteWorkflow(ctx internal.Context, in *internal.ExecuteWorkflowInput) (interface{}, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteWorkflow")
	}

	var r0 interface{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.ExecuteWorkflowInput) (interface{}, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.ExecuteWorkflowInput) interface{}); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func(internal.Context, *internal.ExecuteWorkflowInput) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowInboundInterceptor_ExecuteWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteWorkflow'
type WorkflowInboundInterceptor_ExecuteWorkflow_Call struct {
	*mock.Call
}

// ExecuteWorkflow is a helper method to define mock.On call
//   - ctx internal.Context
//   - in *internal.ExecuteWorkflowInput
func (_e *WorkflowInboundInterceptor_Expecter) ExecuteWorkflow(ctx interface{}, in interface{}) *WorkflowInboundInterceptor_ExecuteWorkflow_Call {
	return &WorkflowInboundInterceptor_ExecuteWorkflow_Call{Call: _e.mock.On("ExecuteWorkflow", ctx, in)}
}

func (_c *WorkflowInboundInterceptor_ExecuteWorkflow_Call) Run(run func(ctx internal.Context, in *internal.ExecuteWorkflowInput)) *WorkflowInboundInterceptor_ExecuteWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 *internal.ExecuteWorkflowInput
		if args[1] != nil {
			arg1 = args[1].(*internal.ExecuteWorkflowInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_ExecuteWorkflow_Call) Return(ifaceVal interface{}, err error) *WorkflowInboundInterceptor_ExecuteWorkflow_Call {
	_c.Call.Return(ifaceVal, err)
	return _c
}

func (_c *WorkflowInboundInterceptor_ExecuteWorkflow_Call) RunAndReturn(run func(ctx internal.Context, in *internal.ExecuteWorkflowInput) (interface{}, error)) *WorkflowInboundInterceptor_ExecuteWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// HandleQuery provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) HandleQuery(ctx internal.Context, in *internal.HandleQueryInput) (interface{}, error) {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for HandleQuery")
	}

	var r0 interface{}
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.HandleQueryInput) (interface{}, error)); ok {
		return returnFunc(ctx, in)
	}
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.HandleQueryInput) interface{}); ok {
		r0 = returnFunc(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}
	if returnFunc, ok := ret.Get(1).(func(internal.Context, *internal.HandleQueryInput) error); ok {
		r1 = returnFunc(ctx, in)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowInboundInterceptor_HandleQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleQuery'
type WorkflowInboundInterceptor_HandleQuery_Call struct {
	*mock.Call
}

// HandleQuery is a helper method to define mock.On call
//   - ctx internal.Context
//   - in *internal.HandleQueryInput
func (_e *WorkflowInboundInterceptor_Expecter) HandleQuery(ctx interface{}, in interface{}) *WorkflowInboundInterceptor_HandleQuery_Call {
	return &WorkflowInboundInterceptor_HandleQuery_Call{Call: _e.mock.On("HandleQuery", ctx, in)}
}

func (_c *WorkflowInboundInterceptor_HandleQuery_Call) Run(run func(ctx internal.Context, in *internal.HandleQueryInput)) *WorkflowInboundInterceptor_HandleQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 *internal.HandleQueryInput
		if args[1] != nil {
			arg1 = args[1].(*internal.HandleQueryInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_HandleQuery_Call) Return(ifaceVal interface{}, err error) *WorkflowInboundInterceptor_HandleQuery_Call {
	_c.Call.Return(ifaceVal, err)
	return _c
}

func (_c *WorkflowInboundInterceptor_HandleQuery_Call) RunAndReturn(run func(ctx internal.Context, in *internal.HandleQueryInput) (interface{}, error)) *WorkflowInboundInterceptor_HandleQuery_Call {
	_c.Call.Return(run)
	return _c
}

// HandleSignal provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) HandleSignal(ctx internal.Context, in *internal.HandleSignalInput) error {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for HandleSignal")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.HandleSignalInput) error); ok {
		r0 = returnFunc(ctx, in)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowInboundInterceptor_HandleSignal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleSignal'
type WorkflowInboundInterceptor_HandleSignal_Call struct {
	*mock.Call
}

// HandleSignal is a helper method to define mock.On call
//   - ctx internal.Context
//   - in *internal.HandleSignalInput
func (_e *WorkflowInboundInterceptor_Expecter) HandleSignal(ctx interface{}, in interface{}) *WorkflowInboundInterceptor_HandleSignal_Call {
	return &WorkflowInboundInterceptor_HandleSignal_Call{Call: _e.mock.On("HandleSignal", ctx, in)}
}

func (_c *WorkflowInboundInterceptor_HandleSignal_Call) Run(run func(ctx internal.Context, in *internal.HandleSignalInput)) *WorkflowInboundInterceptor_HandleSignal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 *internal.HandleSignalInput
		if args[1] != nil {
			arg1 = args[1].(*internal.HandleSignalInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_HandleSignal_Call) Return(err error) *WorkflowInboundInterceptor_HandleSignal_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowInboundInterceptor_HandleSignal_Call) RunAndReturn(run func(ctx internal.Context, in *internal.HandleSignalInput) error) *WorkflowInboundInterceptor_HandleSignal_Call {
	_c.Call.Return(run)
	return _c
}

// Init provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) Init(outbound internal.WorkflowOutboundInterceptor) error {
	ret := _mock.Called(outbound)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.WorkflowOutboundInterceptor) error); ok {
		r0 = returnFunc(outbound)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowInboundInterceptor_Init_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Init'
type WorkflowInboundInterceptor_Init_Call struct {
	*mock.Call
}

// Init is a helper method to define mock.On call
//   - outbound internal.WorkflowOutboundInterceptor
func (_e *WorkflowInboundInterceptor_Expecter) Init(outbound interface{}) *WorkflowInboundInterceptor_Init_Call {
	return &WorkflowInboundInterceptor_Init_Call{Call: _e.mock.On("Init", outbound)}
}

func (_c *WorkflowInboundInterceptor_Init_Call) Run(run func(outbound internal.WorkflowOutboundInterceptor)) *WorkflowInboundInterceptor_Init_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.WorkflowOutboundInterceptor
		if args[0] != nil {
			arg0 = args[0].(internal.WorkflowOutboundInterceptor)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_Init_Call) Return(err error) *WorkflowInboundInterceptor_Init_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowInboundInterceptor_Init_Call) RunAndReturn(run func(outbound internal.WorkflowOutboundInterceptor) error) *WorkflowInboundInterceptor_Init_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateUpdate provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) ValidateUpdate(ctx internal.Context, in *internal.UpdateInput) error {
	ret := _mock.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUpdate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, *internal.UpdateInput) error); ok {
		r0 = returnFunc(ctx, in)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowInboundInterceptor_ValidateUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateUpdate'
type WorkflowInboundInterceptor_ValidateUpdate_Call struct {
	*mock.Call
}

// ValidateUpdate is a helper method to define mock.On call
//   - ctx internal.Context
//   - in *internal.UpdateInput
func (_e *WorkflowInboundInterceptor_Expecter) ValidateUpdate(ctx interface{}, in interface{}) *WorkflowInboundInterceptor_ValidateUpdate_Call {
	return &WorkflowInboundInterceptor_ValidateUpdate_Call{Call: _e.mock.On("ValidateUpdate", ctx, in)}
}

func (_c *WorkflowInboundInterceptor_ValidateUpdate_Call) Run(run func(ctx internal.Context, in *internal.UpdateInput)) *WorkflowInboundInterceptor_ValidateUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 *internal.UpdateInput
		if args[1] != nil {
			arg1 = args[1].(*internal.UpdateInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_ValidateUpdate_Call) Return(err error) *WorkflowInboundInterceptor_ValidateUpdate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowInboundInterceptor_ValidateUpdate_Call) RunAndReturn(run func(ctx internal.Context, in *internal.UpdateInput) error) *WorkflowInboundInterceptor_ValidateUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// mustEmbedWorkflowInboundInterceptorBase provides a mock function for the type WorkflowInboundInterceptor
func (_mock *WorkflowInboundInterceptor) mustEmbedWorkflowInboundInterceptorBase() {
	_mock.Called()
	return
}

// WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mustEmbedWorkflowInboundInterceptorBase'
type WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call struct {
	*mock.Call
}

// mustEmbedWorkflowInboundInterceptorBase is a helper method to define mock.On call
func (_e *WorkflowInboundInterceptor_Expecter) mustEmbedWorkflowInboundInterceptorBase() *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call {
	return &WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call{Call: _e.mock.On("mustEmbedWorkflowInboundInterceptorBase")}
}

func (_c *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call) Run(run func()) *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call) Return() *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call {
	_c.Call.Return()
	return _c
}

func (_c *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call) RunAndReturn(run func()) *WorkflowInboundInterceptor_mustEmbedWorkflowInboundInterceptorBase_Call {
	_c.Run(run)
	return _c
}
