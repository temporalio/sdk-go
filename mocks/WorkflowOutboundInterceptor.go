// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"time"

	mock "github.com/stretchr/testify/mock"
	"go.temporal.io/sdk/converter"
	"go.temporal.io/sdk/internal"
	"go.temporal.io/sdk/internal/common/metrics"
	"go.temporal.io/sdk/log"
)

// NewWorkflowOutboundInterceptor creates a new instance of WorkflowOutboundInterceptor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkflowOutboundInterceptor(t interface {
	mock.TestingT
	Cleanup(func())
}) *WorkflowOutboundInterceptor {
	mock := &WorkflowOutboundInterceptor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WorkflowOutboundInterceptor is an autogenerated mock type for the WorkflowOutboundInterceptor type
type WorkflowOutboundInterceptor struct {
	mock.Mock
}

type WorkflowOutboundInterceptor_Expecter struct {
	mock *mock.Mock
}

func (_m *WorkflowOutboundInterceptor) EXPECT() *WorkflowOutboundInterceptor_Expecter {
	return &WorkflowOutboundInterceptor_Expecter{mock: &_m.Mock}
}

// Await provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) Await(ctx internal.Context, condition func() bool) error {
	ret := _mock.Called(ctx, condition)

	if len(ret) == 0 {
		panic("no return value specified for Await")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, func() bool) error); ok {
		r0 = returnFunc(ctx, condition)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_Await_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Await'
type WorkflowOutboundInterceptor_Await_Call struct {
	*mock.Call
}

// Await is a helper method to define mock.On call
//   - ctx internal.Context
//   - condition func() bool
func (_e *WorkflowOutboundInterceptor_Expecter) Await(ctx interface{}, condition interface{}) *WorkflowOutboundInterceptor_Await_Call {
	return &WorkflowOutboundInterceptor_Await_Call{Call: _e.mock.On("Await", ctx, condition)}
}

func (_c *WorkflowOutboundInterceptor_Await_Call) Run(run func(ctx internal.Context, condition func() bool)) *WorkflowOutboundInterceptor_Await_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 func() bool
		if args[1] != nil {
			arg1 = args[1].(func() bool)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_Await_Call) Return(err error) *WorkflowOutboundInterceptor_Await_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_Await_Call) RunAndReturn(run func(ctx internal.Context, condition func() bool) error) *WorkflowOutboundInterceptor_Await_Call {
	_c.Call.Return(run)
	return _c
}

// AwaitWithOptions provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) AwaitWithOptions(ctx internal.Context, options internal.AwaitOptions, condition func() bool) (bool, error) {
	ret := _mock.Called(ctx, options, condition)

	if len(ret) == 0 {
		panic("no return value specified for AwaitWithOptions")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, internal.AwaitOptions, func() bool) (bool, error)); ok {
		return returnFunc(ctx, options, condition)
	}
	if returnFunc, ok := ret.Get(0).(func(internal.Context, internal.AwaitOptions, func() bool) bool); ok {
		r0 = returnFunc(ctx, options, condition)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(internal.Context, internal.AwaitOptions, func() bool) error); ok {
		r1 = returnFunc(ctx, options, condition)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowOutboundInterceptor_AwaitWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AwaitWithOptions'
type WorkflowOutboundInterceptor_AwaitWithOptions_Call struct {
	*mock.Call
}

// AwaitWithOptions is a helper method to define mock.On call
//   - ctx internal.Context
//   - options internal.AwaitOptions
//   - condition func() bool
func (_e *WorkflowOutboundInterceptor_Expecter) AwaitWithOptions(ctx interface{}, options interface{}, condition interface{}) *WorkflowOutboundInterceptor_AwaitWithOptions_Call {
	return &WorkflowOutboundInterceptor_AwaitWithOptions_Call{Call: _e.mock.On("AwaitWithOptions", ctx, options, condition)}
}

func (_c *WorkflowOutboundInterceptor_AwaitWithOptions_Call) Run(run func(ctx internal.Context, options internal.AwaitOptions, condition func() bool)) *WorkflowOutboundInterceptor_AwaitWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 internal.AwaitOptions
		if args[1] != nil {
			arg1 = args[1].(internal.AwaitOptions)
		}
		var arg2 func() bool
		if args[2] != nil {
			arg2 = args[2].(func() bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_AwaitWithOptions_Call) Return(b bool, err error) *WorkflowOutboundInterceptor_AwaitWithOptions_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_AwaitWithOptions_Call) RunAndReturn(run func(ctx internal.Context, options internal.AwaitOptions, condition func() bool) (bool, error)) *WorkflowOutboundInterceptor_AwaitWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// AwaitWithTimeout provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) AwaitWithTimeout(ctx internal.Context, timeout time.Duration, condition func() bool) (bool, error) {
	ret := _mock.Called(ctx, timeout, condition)

	if len(ret) == 0 {
		panic("no return value specified for AwaitWithTimeout")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, time.Duration, func() bool) (bool, error)); ok {
		return returnFunc(ctx, timeout, condition)
	}
	if returnFunc, ok := ret.Get(0).(func(internal.Context, time.Duration, func() bool) bool); ok {
		r0 = returnFunc(ctx, timeout, condition)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(internal.Context, time.Duration, func() bool) error); ok {
		r1 = returnFunc(ctx, timeout, condition)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorkflowOutboundInterceptor_AwaitWithTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AwaitWithTimeout'
type WorkflowOutboundInterceptor_AwaitWithTimeout_Call struct {
	*mock.Call
}

// AwaitWithTimeout is a helper method to define mock.On call
//   - ctx internal.Context
//   - timeout time.Duration
//   - condition func() bool
func (_e *WorkflowOutboundInterceptor_Expecter) AwaitWithTimeout(ctx interface{}, timeout interface{}, condition interface{}) *WorkflowOutboundInterceptor_AwaitWithTimeout_Call {
	return &WorkflowOutboundInterceptor_AwaitWithTimeout_Call{Call: _e.mock.On("AwaitWithTimeout", ctx, timeout, condition)}
}

func (_c *WorkflowOutboundInterceptor_AwaitWithTimeout_Call) Run(run func(ctx internal.Context, timeout time.Duration, condition func() bool)) *WorkflowOutboundInterceptor_AwaitWithTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		var arg2 func() bool
		if args[2] != nil {
			arg2 = args[2].(func() bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_AwaitWithTimeout_Call) Return(b bool, err error) *WorkflowOutboundInterceptor_AwaitWithTimeout_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_AwaitWithTimeout_Call) RunAndReturn(run func(ctx internal.Context, timeout time.Duration, condition func() bool) (bool, error)) *WorkflowOutboundInterceptor_AwaitWithTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteActivity provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) ExecuteActivity(ctx internal.Context, activityType string, args ...interface{}) internal.Future {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, activityType, args)
	} else {
		tmpRet = _mock.Called(ctx, activityType)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ExecuteActivity")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, ...interface{}) internal.Future); ok {
		r0 = returnFunc(ctx, activityType, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_ExecuteActivity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteActivity'
type WorkflowOutboundInterceptor_ExecuteActivity_Call struct {
	*mock.Call
}

// ExecuteActivity is a helper method to define mock.On call
//   - ctx internal.Context
//   - activityType string
//   - args ...interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) ExecuteActivity(ctx interface{}, activityType interface{}, args ...interface{}) *WorkflowOutboundInterceptor_ExecuteActivity_Call {
	return &WorkflowOutboundInterceptor_ExecuteActivity_Call{Call: _e.mock.On("ExecuteActivity",
		append([]interface{}{ctx, activityType}, args...)...)}
}

func (_c *WorkflowOutboundInterceptor_ExecuteActivity_Call) Run(run func(ctx internal.Context, activityType string, args ...interface{})) *WorkflowOutboundInterceptor_ExecuteActivity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []interface{}
		var variadicArgs []interface{}
		if len(args) > 2 {
			variadicArgs = args[2].([]interface{})
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteActivity_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_ExecuteActivity_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteActivity_Call) RunAndReturn(run func(ctx internal.Context, activityType string, args ...interface{}) internal.Future) *WorkflowOutboundInterceptor_ExecuteActivity_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteChildWorkflow provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) ExecuteChildWorkflow(ctx internal.Context, childWorkflowType string, args ...interface{}) internal.ChildWorkflowFuture {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, childWorkflowType, args)
	} else {
		tmpRet = _mock.Called(ctx, childWorkflowType)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ExecuteChildWorkflow")
	}

	var r0 internal.ChildWorkflowFuture
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, ...interface{}) internal.ChildWorkflowFuture); ok {
		r0 = returnFunc(ctx, childWorkflowType, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.ChildWorkflowFuture)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteChildWorkflow'
type WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call struct {
	*mock.Call
}

// ExecuteChildWorkflow is a helper method to define mock.On call
//   - ctx internal.Context
//   - childWorkflowType string
//   - args ...interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) ExecuteChildWorkflow(ctx interface{}, childWorkflowType interface{}, args ...interface{}) *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call {
	return &WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call{Call: _e.mock.On("ExecuteChildWorkflow",
		append([]interface{}{ctx, childWorkflowType}, args...)...)}
}

func (_c *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call) Run(run func(ctx internal.Context, childWorkflowType string, args ...interface{})) *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []interface{}
		var variadicArgs []interface{}
		if len(args) > 2 {
			variadicArgs = args[2].([]interface{})
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call) Return(childWorkflowFuture internal.ChildWorkflowFuture) *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call {
	_c.Call.Return(childWorkflowFuture)
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call) RunAndReturn(run func(ctx internal.Context, childWorkflowType string, args ...interface{}) internal.ChildWorkflowFuture) *WorkflowOutboundInterceptor_ExecuteChildWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteLocalActivity provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) ExecuteLocalActivity(ctx internal.Context, activityType string, args ...interface{}) internal.Future {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, activityType, args)
	} else {
		tmpRet = _mock.Called(ctx, activityType)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ExecuteLocalActivity")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, ...interface{}) internal.Future); ok {
		r0 = returnFunc(ctx, activityType, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_ExecuteLocalActivity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteLocalActivity'
type WorkflowOutboundInterceptor_ExecuteLocalActivity_Call struct {
	*mock.Call
}

// ExecuteLocalActivity is a helper method to define mock.On call
//   - ctx internal.Context
//   - activityType string
//   - args ...interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) ExecuteLocalActivity(ctx interface{}, activityType interface{}, args ...interface{}) *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call {
	return &WorkflowOutboundInterceptor_ExecuteLocalActivity_Call{Call: _e.mock.On("ExecuteLocalActivity",
		append([]interface{}{ctx, activityType}, args...)...)}
}

func (_c *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call) Run(run func(ctx internal.Context, activityType string, args ...interface{})) *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []interface{}
		var variadicArgs []interface{}
		if len(args) > 2 {
			variadicArgs = args[2].([]interface{})
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call) RunAndReturn(run func(ctx internal.Context, activityType string, args ...interface{}) internal.Future) *WorkflowOutboundInterceptor_ExecuteLocalActivity_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteNexusOperation provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) ExecuteNexusOperation(ctx internal.Context, input internal.ExecuteNexusOperationInput) internal.NexusOperationFuture {
	ret := _mock.Called(ctx, input)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteNexusOperation")
	}

	var r0 internal.NexusOperationFuture
	if returnFunc, ok := ret.Get(0).(func(internal.Context, internal.ExecuteNexusOperationInput) internal.NexusOperationFuture); ok {
		r0 = returnFunc(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.NexusOperationFuture)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_ExecuteNexusOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteNexusOperation'
type WorkflowOutboundInterceptor_ExecuteNexusOperation_Call struct {
	*mock.Call
}

// ExecuteNexusOperation is a helper method to define mock.On call
//   - ctx internal.Context
//   - input internal.ExecuteNexusOperationInput
func (_e *WorkflowOutboundInterceptor_Expecter) ExecuteNexusOperation(ctx interface{}, input interface{}) *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call {
	return &WorkflowOutboundInterceptor_ExecuteNexusOperation_Call{Call: _e.mock.On("ExecuteNexusOperation", ctx, input)}
}

func (_c *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call) Run(run func(ctx internal.Context, input internal.ExecuteNexusOperationInput)) *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 internal.ExecuteNexusOperationInput
		if args[1] != nil {
			arg1 = args[1].(internal.ExecuteNexusOperationInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call) Return(nexusOperationFuture internal.NexusOperationFuture) *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call {
	_c.Call.Return(nexusOperationFuture)
	return _c
}

func (_c *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call) RunAndReturn(run func(ctx internal.Context, input internal.ExecuteNexusOperationInput) internal.NexusOperationFuture) *WorkflowOutboundInterceptor_ExecuteNexusOperation_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentUpdateInfo provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetCurrentUpdateInfo(ctx internal.Context) *internal.UpdateInfo {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentUpdateInfo")
	}

	var r0 *internal.UpdateInfo
	if returnFunc, ok := ret.Get(0).(func(internal.Context) *internal.UpdateInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal.UpdateInfo)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentUpdateInfo'
type WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call struct {
	*mock.Call
}

// GetCurrentUpdateInfo is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) GetCurrentUpdateInfo(ctx interface{}) *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call {
	return &WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call{Call: _e.mock.On("GetCurrentUpdateInfo", ctx)}
}

func (_c *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call) Return(updateInfo *internal.UpdateInfo) *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call {
	_c.Call.Return(updateInfo)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call) RunAndReturn(run func(ctx internal.Context) *internal.UpdateInfo) *WorkflowOutboundInterceptor_GetCurrentUpdateInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetInfo provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetInfo(ctx internal.Context) *internal.WorkflowInfo {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 *internal.WorkflowInfo
	if returnFunc, ok := ret.Get(0).(func(internal.Context) *internal.WorkflowInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*internal.WorkflowInfo)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_GetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInfo'
type WorkflowOutboundInterceptor_GetInfo_Call struct {
	*mock.Call
}

// GetInfo is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) GetInfo(ctx interface{}) *WorkflowOutboundInterceptor_GetInfo_Call {
	return &WorkflowOutboundInterceptor_GetInfo_Call{Call: _e.mock.On("GetInfo", ctx)}
}

func (_c *WorkflowOutboundInterceptor_GetInfo_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_GetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetInfo_Call) Return(workflowInfo *internal.WorkflowInfo) *WorkflowOutboundInterceptor_GetInfo_Call {
	_c.Call.Return(workflowInfo)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetInfo_Call) RunAndReturn(run func(ctx internal.Context) *internal.WorkflowInfo) *WorkflowOutboundInterceptor_GetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastCompletionResult provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetLastCompletionResult(ctx internal.Context, d ...interface{}) error {
	var tmpRet mock.Arguments
	if len(d) > 0 {
		tmpRet = _mock.Called(ctx, d)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetLastCompletionResult")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, ...interface{}) error); ok {
		r0 = returnFunc(ctx, d...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_GetLastCompletionResult_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastCompletionResult'
type WorkflowOutboundInterceptor_GetLastCompletionResult_Call struct {
	*mock.Call
}

// GetLastCompletionResult is a helper method to define mock.On call
//   - ctx internal.Context
//   - d ...interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) GetLastCompletionResult(ctx interface{}, d ...interface{}) *WorkflowOutboundInterceptor_GetLastCompletionResult_Call {
	return &WorkflowOutboundInterceptor_GetLastCompletionResult_Call{Call: _e.mock.On("GetLastCompletionResult",
		append([]interface{}{ctx}, d...)...)}
}

func (_c *WorkflowOutboundInterceptor_GetLastCompletionResult_Call) Run(run func(ctx internal.Context, d ...interface{})) *WorkflowOutboundInterceptor_GetLastCompletionResult_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 []interface{}
		var variadicArgs []interface{}
		if len(args) > 1 {
			variadicArgs = args[1].([]interface{})
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetLastCompletionResult_Call) Return(err error) *WorkflowOutboundInterceptor_GetLastCompletionResult_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetLastCompletionResult_Call) RunAndReturn(run func(ctx internal.Context, d ...interface{}) error) *WorkflowOutboundInterceptor_GetLastCompletionResult_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastError provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetLastError(ctx internal.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastError")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_GetLastError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastError'
type WorkflowOutboundInterceptor_GetLastError_Call struct {
	*mock.Call
}

// GetLastError is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) GetLastError(ctx interface{}) *WorkflowOutboundInterceptor_GetLastError_Call {
	return &WorkflowOutboundInterceptor_GetLastError_Call{Call: _e.mock.On("GetLastError", ctx)}
}

func (_c *WorkflowOutboundInterceptor_GetLastError_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_GetLastError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetLastError_Call) Return(err error) *WorkflowOutboundInterceptor_GetLastError_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetLastError_Call) RunAndReturn(run func(ctx internal.Context) error) *WorkflowOutboundInterceptor_GetLastError_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogger provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetLogger(ctx internal.Context) log.Logger {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLogger")
	}

	var r0 log.Logger
	if returnFunc, ok := ret.Get(0).(func(internal.Context) log.Logger); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(log.Logger)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_GetLogger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogger'
type WorkflowOutboundInterceptor_GetLogger_Call struct {
	*mock.Call
}

// GetLogger is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) GetLogger(ctx interface{}) *WorkflowOutboundInterceptor_GetLogger_Call {
	return &WorkflowOutboundInterceptor_GetLogger_Call{Call: _e.mock.On("GetLogger", ctx)}
}

func (_c *WorkflowOutboundInterceptor_GetLogger_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_GetLogger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetLogger_Call) Return(logger log.Logger) *WorkflowOutboundInterceptor_GetLogger_Call {
	_c.Call.Return(logger)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetLogger_Call) RunAndReturn(run func(ctx internal.Context) log.Logger) *WorkflowOutboundInterceptor_GetLogger_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetricsHandler provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetMetricsHandler(ctx internal.Context) metrics.Handler {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetMetricsHandler")
	}

	var r0 metrics.Handler
	if returnFunc, ok := ret.Get(0).(func(internal.Context) metrics.Handler); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metrics.Handler)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_GetMetricsHandler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetricsHandler'
type WorkflowOutboundInterceptor_GetMetricsHandler_Call struct {
	*mock.Call
}

// GetMetricsHandler is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) GetMetricsHandler(ctx interface{}) *WorkflowOutboundInterceptor_GetMetricsHandler_Call {
	return &WorkflowOutboundInterceptor_GetMetricsHandler_Call{Call: _e.mock.On("GetMetricsHandler", ctx)}
}

func (_c *WorkflowOutboundInterceptor_GetMetricsHandler_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_GetMetricsHandler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetMetricsHandler_Call) Return(handler metrics.Handler) *WorkflowOutboundInterceptor_GetMetricsHandler_Call {
	_c.Call.Return(handler)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetMetricsHandler_Call) RunAndReturn(run func(ctx internal.Context) metrics.Handler) *WorkflowOutboundInterceptor_GetMetricsHandler_Call {
	_c.Call.Return(run)
	return _c
}

// GetSignalChannel provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetSignalChannel(ctx internal.Context, signalName string) internal.ReceiveChannel {
	ret := _mock.Called(ctx, signalName)

	if len(ret) == 0 {
		panic("no return value specified for GetSignalChannel")
	}

	var r0 internal.ReceiveChannel
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string) internal.ReceiveChannel); ok {
		r0 = returnFunc(ctx, signalName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.ReceiveChannel)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_GetSignalChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSignalChannel'
type WorkflowOutboundInterceptor_GetSignalChannel_Call struct {
	*mock.Call
}

// GetSignalChannel is a helper method to define mock.On call
//   - ctx internal.Context
//   - signalName string
func (_e *WorkflowOutboundInterceptor_Expecter) GetSignalChannel(ctx interface{}, signalName interface{}) *WorkflowOutboundInterceptor_GetSignalChannel_Call {
	return &WorkflowOutboundInterceptor_GetSignalChannel_Call{Call: _e.mock.On("GetSignalChannel", ctx, signalName)}
}

func (_c *WorkflowOutboundInterceptor_GetSignalChannel_Call) Run(run func(ctx internal.Context, signalName string)) *WorkflowOutboundInterceptor_GetSignalChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetSignalChannel_Call) Return(receiveChannel internal.ReceiveChannel) *WorkflowOutboundInterceptor_GetSignalChannel_Call {
	_c.Call.Return(receiveChannel)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetSignalChannel_Call) RunAndReturn(run func(ctx internal.Context, signalName string) internal.ReceiveChannel) *WorkflowOutboundInterceptor_GetSignalChannel_Call {
	_c.Call.Return(run)
	return _c
}

// GetSignalChannelWithOptions provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetSignalChannelWithOptions(ctx internal.Context, signalName string, options internal.SignalChannelOptions) internal.ReceiveChannel {
	ret := _mock.Called(ctx, signalName, options)

	if len(ret) == 0 {
		panic("no return value specified for GetSignalChannelWithOptions")
	}

	var r0 internal.ReceiveChannel
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, internal.SignalChannelOptions) internal.ReceiveChannel); ok {
		r0 = returnFunc(ctx, signalName, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.ReceiveChannel)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSignalChannelWithOptions'
type WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call struct {
	*mock.Call
}

// GetSignalChannelWithOptions is a helper method to define mock.On call
//   - ctx internal.Context
//   - signalName string
//   - options internal.SignalChannelOptions
func (_e *WorkflowOutboundInterceptor_Expecter) GetSignalChannelWithOptions(ctx interface{}, signalName interface{}, options interface{}) *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call {
	return &WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call{Call: _e.mock.On("GetSignalChannelWithOptions", ctx, signalName, options)}
}

func (_c *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call) Run(run func(ctx internal.Context, signalName string, options internal.SignalChannelOptions)) *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 internal.SignalChannelOptions
		if args[2] != nil {
			arg2 = args[2].(internal.SignalChannelOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call) Return(receiveChannel internal.ReceiveChannel) *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call {
	_c.Call.Return(receiveChannel)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call) RunAndReturn(run func(ctx internal.Context, signalName string, options internal.SignalChannelOptions) internal.ReceiveChannel) *WorkflowOutboundInterceptor_GetSignalChannelWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// GetTypedSearchAttributes provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetTypedSearchAttributes(ctx internal.Context) internal.SearchAttributes {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetTypedSearchAttributes")
	}

	var r0 internal.SearchAttributes
	if returnFunc, ok := ret.Get(0).(func(internal.Context) internal.SearchAttributes); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(internal.SearchAttributes)
	}
	return r0
}

// WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTypedSearchAttributes'
type WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call struct {
	*mock.Call
}

// GetTypedSearchAttributes is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) GetTypedSearchAttributes(ctx interface{}) *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call {
	return &WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call{Call: _e.mock.On("GetTypedSearchAttributes", ctx)}
}

func (_c *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call) Return(searchAttributes internal.SearchAttributes) *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call {
	_c.Call.Return(searchAttributes)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call) RunAndReturn(run func(ctx internal.Context) internal.SearchAttributes) *WorkflowOutboundInterceptor_GetTypedSearchAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersion provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) GetVersion(ctx internal.Context, changeID string, minSupported internal.Version, maxSupported internal.Version) internal.Version {
	ret := _mock.Called(ctx, changeID, minSupported, maxSupported)

	if len(ret) == 0 {
		panic("no return value specified for GetVersion")
	}

	var r0 internal.Version
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, internal.Version, internal.Version) internal.Version); ok {
		r0 = returnFunc(ctx, changeID, minSupported, maxSupported)
	} else {
		r0 = ret.Get(0).(internal.Version)
	}
	return r0
}

// WorkflowOutboundInterceptor_GetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersion'
type WorkflowOutboundInterceptor_GetVersion_Call struct {
	*mock.Call
}

// GetVersion is a helper method to define mock.On call
//   - ctx internal.Context
//   - changeID string
//   - minSupported internal.Version
//   - maxSupported internal.Version
func (_e *WorkflowOutboundInterceptor_Expecter) GetVersion(ctx interface{}, changeID interface{}, minSupported interface{}, maxSupported interface{}) *WorkflowOutboundInterceptor_GetVersion_Call {
	return &WorkflowOutboundInterceptor_GetVersion_Call{Call: _e.mock.On("GetVersion", ctx, changeID, minSupported, maxSupported)}
}

func (_c *WorkflowOutboundInterceptor_GetVersion_Call) Run(run func(ctx internal.Context, changeID string, minSupported internal.Version, maxSupported internal.Version)) *WorkflowOutboundInterceptor_GetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 internal.Version
		if args[2] != nil {
			arg2 = args[2].(internal.Version)
		}
		var arg3 internal.Version
		if args[3] != nil {
			arg3 = args[3].(internal.Version)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetVersion_Call) Return(version internal.Version) *WorkflowOutboundInterceptor_GetVersion_Call {
	_c.Call.Return(version)
	return _c
}

func (_c *WorkflowOutboundInterceptor_GetVersion_Call) RunAndReturn(run func(ctx internal.Context, changeID string, minSupported internal.Version, maxSupported internal.Version) internal.Version) *WorkflowOutboundInterceptor_GetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Go provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) Go(ctx internal.Context, name string, f func(ctx internal.Context)) internal.Context {
	ret := _mock.Called(ctx, name, f)

	if len(ret) == 0 {
		panic("no return value specified for Go")
	}

	var r0 internal.Context
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, func(ctx internal.Context)) internal.Context); ok {
		r0 = returnFunc(ctx, name, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Context)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_Go_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Go'
type WorkflowOutboundInterceptor_Go_Call struct {
	*mock.Call
}

// Go is a helper method to define mock.On call
//   - ctx internal.Context
//   - name string
//   - f func(ctx internal.Context)
func (_e *WorkflowOutboundInterceptor_Expecter) Go(ctx interface{}, name interface{}, f interface{}) *WorkflowOutboundInterceptor_Go_Call {
	return &WorkflowOutboundInterceptor_Go_Call{Call: _e.mock.On("Go", ctx, name, f)}
}

func (_c *WorkflowOutboundInterceptor_Go_Call) Run(run func(ctx internal.Context, name string, f func(ctx internal.Context))) *WorkflowOutboundInterceptor_Go_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 func(ctx internal.Context)
		if args[2] != nil {
			arg2 = args[2].(func(ctx internal.Context))
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_Go_Call) Return(context internal.Context) *WorkflowOutboundInterceptor_Go_Call {
	_c.Call.Return(context)
	return _c
}

func (_c *WorkflowOutboundInterceptor_Go_Call) RunAndReturn(run func(ctx internal.Context, name string, f func(ctx internal.Context)) internal.Context) *WorkflowOutboundInterceptor_Go_Call {
	_c.Call.Return(run)
	return _c
}

// HasLastCompletionResult provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) HasLastCompletionResult(ctx internal.Context) bool {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for HasLastCompletionResult")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(internal.Context) bool); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// WorkflowOutboundInterceptor_HasLastCompletionResult_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasLastCompletionResult'
type WorkflowOutboundInterceptor_HasLastCompletionResult_Call struct {
	*mock.Call
}

// HasLastCompletionResult is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) HasLastCompletionResult(ctx interface{}) *WorkflowOutboundInterceptor_HasLastCompletionResult_Call {
	return &WorkflowOutboundInterceptor_HasLastCompletionResult_Call{Call: _e.mock.On("HasLastCompletionResult", ctx)}
}

func (_c *WorkflowOutboundInterceptor_HasLastCompletionResult_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_HasLastCompletionResult_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_HasLastCompletionResult_Call) Return(b bool) *WorkflowOutboundInterceptor_HasLastCompletionResult_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *WorkflowOutboundInterceptor_HasLastCompletionResult_Call) RunAndReturn(run func(ctx internal.Context) bool) *WorkflowOutboundInterceptor_HasLastCompletionResult_Call {
	_c.Call.Return(run)
	return _c
}

// IsReplaying provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) IsReplaying(ctx internal.Context) bool {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for IsReplaying")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(internal.Context) bool); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// WorkflowOutboundInterceptor_IsReplaying_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsReplaying'
type WorkflowOutboundInterceptor_IsReplaying_Call struct {
	*mock.Call
}

// IsReplaying is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) IsReplaying(ctx interface{}) *WorkflowOutboundInterceptor_IsReplaying_Call {
	return &WorkflowOutboundInterceptor_IsReplaying_Call{Call: _e.mock.On("IsReplaying", ctx)}
}

func (_c *WorkflowOutboundInterceptor_IsReplaying_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_IsReplaying_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_IsReplaying_Call) Return(b bool) *WorkflowOutboundInterceptor_IsReplaying_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *WorkflowOutboundInterceptor_IsReplaying_Call) RunAndReturn(run func(ctx internal.Context) bool) *WorkflowOutboundInterceptor_IsReplaying_Call {
	_c.Call.Return(run)
	return _c
}

// MutableSideEffect provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) MutableSideEffect(ctx internal.Context, id string, f func(ctx internal.Context) interface{}, equals func(a interface{}, b interface{}) bool) converter.EncodedValue {
	ret := _mock.Called(ctx, id, f, equals)

	if len(ret) == 0 {
		panic("no return value specified for MutableSideEffect")
	}

	var r0 converter.EncodedValue
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, func(ctx internal.Context) interface{}, func(a interface{}, b interface{}) bool) converter.EncodedValue); ok {
		r0 = returnFunc(ctx, id, f, equals)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(converter.EncodedValue)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_MutableSideEffect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MutableSideEffect'
type WorkflowOutboundInterceptor_MutableSideEffect_Call struct {
	*mock.Call
}

// MutableSideEffect is a helper method to define mock.On call
//   - ctx internal.Context
//   - id string
//   - f func(ctx internal.Context) interface{}
//   - equals func(a interface{}, b interface{}) bool
func (_e *WorkflowOutboundInterceptor_Expecter) MutableSideEffect(ctx interface{}, id interface{}, f interface{}, equals interface{}) *WorkflowOutboundInterceptor_MutableSideEffect_Call {
	return &WorkflowOutboundInterceptor_MutableSideEffect_Call{Call: _e.mock.On("MutableSideEffect", ctx, id, f, equals)}
}

func (_c *WorkflowOutboundInterceptor_MutableSideEffect_Call) Run(run func(ctx internal.Context, id string, f func(ctx internal.Context) interface{}, equals func(a interface{}, b interface{}) bool)) *WorkflowOutboundInterceptor_MutableSideEffect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 func(ctx internal.Context) interface{}
		if args[2] != nil {
			arg2 = args[2].(func(ctx internal.Context) interface{})
		}
		var arg3 func(a interface{}, b interface{}) bool
		if args[3] != nil {
			arg3 = args[3].(func(a interface{}, b interface{}) bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_MutableSideEffect_Call) Return(encodedValue converter.EncodedValue) *WorkflowOutboundInterceptor_MutableSideEffect_Call {
	_c.Call.Return(encodedValue)
	return _c
}

func (_c *WorkflowOutboundInterceptor_MutableSideEffect_Call) RunAndReturn(run func(ctx internal.Context, id string, f func(ctx internal.Context) interface{}, equals func(a interface{}, b interface{}) bool) converter.EncodedValue) *WorkflowOutboundInterceptor_MutableSideEffect_Call {
	_c.Call.Return(run)
	return _c
}

// MutableSideEffectWithOptions provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) MutableSideEffectWithOptions(ctx internal.Context, id string, options internal.MutableSideEffectOptions, f func(ctx internal.Context) interface{}, equals func(a interface{}, b interface{}) bool) converter.EncodedValue {
	ret := _mock.Called(ctx, id, options, f, equals)

	if len(ret) == 0 {
		panic("no return value specified for MutableSideEffectWithOptions")
	}

	var r0 converter.EncodedValue
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, internal.MutableSideEffectOptions, func(ctx internal.Context) interface{}, func(a interface{}, b interface{}) bool) converter.EncodedValue); ok {
		r0 = returnFunc(ctx, id, options, f, equals)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(converter.EncodedValue)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MutableSideEffectWithOptions'
type WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call struct {
	*mock.Call
}

// MutableSideEffectWithOptions is a helper method to define mock.On call
//   - ctx internal.Context
//   - id string
//   - options internal.MutableSideEffectOptions
//   - f func(ctx internal.Context) interface{}
//   - equals func(a interface{}, b interface{}) bool
func (_e *WorkflowOutboundInterceptor_Expecter) MutableSideEffectWithOptions(ctx interface{}, id interface{}, options interface{}, f interface{}, equals interface{}) *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call {
	return &WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call{Call: _e.mock.On("MutableSideEffectWithOptions", ctx, id, options, f, equals)}
}

func (_c *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call) Run(run func(ctx internal.Context, id string, options internal.MutableSideEffectOptions, f func(ctx internal.Context) interface{}, equals func(a interface{}, b interface{}) bool)) *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 internal.MutableSideEffectOptions
		if args[2] != nil {
			arg2 = args[2].(internal.MutableSideEffectOptions)
		}
		var arg3 func(ctx internal.Context) interface{}
		if args[3] != nil {
			arg3 = args[3].(func(ctx internal.Context) interface{})
		}
		var arg4 func(a interface{}, b interface{}) bool
		if args[4] != nil {
			arg4 = args[4].(func(a interface{}, b interface{}) bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call) Return(encodedValue converter.EncodedValue) *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call {
	_c.Call.Return(encodedValue)
	return _c
}

func (_c *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call) RunAndReturn(run func(ctx internal.Context, id string, options internal.MutableSideEffectOptions, f func(ctx internal.Context) interface{}, equals func(a interface{}, b interface{}) bool) converter.EncodedValue) *WorkflowOutboundInterceptor_MutableSideEffectWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// NewContinueAsNewError provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) NewContinueAsNewError(ctx internal.Context, wfn interface{}, args ...interface{}) error {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, wfn, args)
	} else {
		tmpRet = _mock.Called(ctx, wfn)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for NewContinueAsNewError")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, interface{}, ...interface{}) error); ok {
		r0 = returnFunc(ctx, wfn, args...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_NewContinueAsNewError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewContinueAsNewError'
type WorkflowOutboundInterceptor_NewContinueAsNewError_Call struct {
	*mock.Call
}

// NewContinueAsNewError is a helper method to define mock.On call
//   - ctx internal.Context
//   - wfn interface{}
//   - args ...interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) NewContinueAsNewError(ctx interface{}, wfn interface{}, args ...interface{}) *WorkflowOutboundInterceptor_NewContinueAsNewError_Call {
	return &WorkflowOutboundInterceptor_NewContinueAsNewError_Call{Call: _e.mock.On("NewContinueAsNewError",
		append([]interface{}{ctx, wfn}, args...)...)}
}

func (_c *WorkflowOutboundInterceptor_NewContinueAsNewError_Call) Run(run func(ctx internal.Context, wfn interface{}, args ...interface{})) *WorkflowOutboundInterceptor_NewContinueAsNewError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 interface{}
		if args[1] != nil {
			arg1 = args[1].(interface{})
		}
		var arg2 []interface{}
		var variadicArgs []interface{}
		if len(args) > 2 {
			variadicArgs = args[2].([]interface{})
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_NewContinueAsNewError_Call) Return(err error) *WorkflowOutboundInterceptor_NewContinueAsNewError_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_NewContinueAsNewError_Call) RunAndReturn(run func(ctx internal.Context, wfn interface{}, args ...interface{}) error) *WorkflowOutboundInterceptor_NewContinueAsNewError_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimer provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) NewTimer(ctx internal.Context, d time.Duration) internal.Future {
	ret := _mock.Called(ctx, d)

	if len(ret) == 0 {
		panic("no return value specified for NewTimer")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, time.Duration) internal.Future); ok {
		r0 = returnFunc(ctx, d)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_NewTimer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewTimer'
type WorkflowOutboundInterceptor_NewTimer_Call struct {
	*mock.Call
}

// NewTimer is a helper method to define mock.On call
//   - ctx internal.Context
//   - d time.Duration
func (_e *WorkflowOutboundInterceptor_Expecter) NewTimer(ctx interface{}, d interface{}) *WorkflowOutboundInterceptor_NewTimer_Call {
	return &WorkflowOutboundInterceptor_NewTimer_Call{Call: _e.mock.On("NewTimer", ctx, d)}
}

func (_c *WorkflowOutboundInterceptor_NewTimer_Call) Run(run func(ctx internal.Context, d time.Duration)) *WorkflowOutboundInterceptor_NewTimer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_NewTimer_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_NewTimer_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_NewTimer_Call) RunAndReturn(run func(ctx internal.Context, d time.Duration) internal.Future) *WorkflowOutboundInterceptor_NewTimer_Call {
	_c.Call.Return(run)
	return _c
}

// NewTimerWithOptions provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) NewTimerWithOptions(ctx internal.Context, d time.Duration, options internal.TimerOptions) internal.Future {
	ret := _mock.Called(ctx, d, options)

	if len(ret) == 0 {
		panic("no return value specified for NewTimerWithOptions")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, time.Duration, internal.TimerOptions) internal.Future); ok {
		r0 = returnFunc(ctx, d, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_NewTimerWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewTimerWithOptions'
type WorkflowOutboundInterceptor_NewTimerWithOptions_Call struct {
	*mock.Call
}

// NewTimerWithOptions is a helper method to define mock.On call
//   - ctx internal.Context
//   - d time.Duration
//   - options internal.TimerOptions
func (_e *WorkflowOutboundInterceptor_Expecter) NewTimerWithOptions(ctx interface{}, d interface{}, options interface{}) *WorkflowOutboundInterceptor_NewTimerWithOptions_Call {
	return &WorkflowOutboundInterceptor_NewTimerWithOptions_Call{Call: _e.mock.On("NewTimerWithOptions", ctx, d, options)}
}

func (_c *WorkflowOutboundInterceptor_NewTimerWithOptions_Call) Run(run func(ctx internal.Context, d time.Duration, options internal.TimerOptions)) *WorkflowOutboundInterceptor_NewTimerWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		var arg2 internal.TimerOptions
		if args[2] != nil {
			arg2 = args[2].(internal.TimerOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_NewTimerWithOptions_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_NewTimerWithOptions_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_NewTimerWithOptions_Call) RunAndReturn(run func(ctx internal.Context, d time.Duration, options internal.TimerOptions) internal.Future) *WorkflowOutboundInterceptor_NewTimerWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Now provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) Now(ctx internal.Context) time.Time {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Now")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func(internal.Context) time.Time); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// WorkflowOutboundInterceptor_Now_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Now'
type WorkflowOutboundInterceptor_Now_Call struct {
	*mock.Call
}

// Now is a helper method to define mock.On call
//   - ctx internal.Context
func (_e *WorkflowOutboundInterceptor_Expecter) Now(ctx interface{}) *WorkflowOutboundInterceptor_Now_Call {
	return &WorkflowOutboundInterceptor_Now_Call{Call: _e.mock.On("Now", ctx)}
}

func (_c *WorkflowOutboundInterceptor_Now_Call) Run(run func(ctx internal.Context)) *WorkflowOutboundInterceptor_Now_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_Now_Call) Return(time1 time.Time) *WorkflowOutboundInterceptor_Now_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *WorkflowOutboundInterceptor_Now_Call) RunAndReturn(run func(ctx internal.Context) time.Time) *WorkflowOutboundInterceptor_Now_Call {
	_c.Call.Return(run)
	return _c
}

// RequestCancelExternalWorkflow provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) RequestCancelExternalWorkflow(ctx internal.Context, workflowID string, runID string) internal.Future {
	ret := _mock.Called(ctx, workflowID, runID)

	if len(ret) == 0 {
		panic("no return value specified for RequestCancelExternalWorkflow")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, string) internal.Future); ok {
		r0 = returnFunc(ctx, workflowID, runID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestCancelExternalWorkflow'
type WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call struct {
	*mock.Call
}

// RequestCancelExternalWorkflow is a helper method to define mock.On call
//   - ctx internal.Context
//   - workflowID string
//   - runID string
func (_e *WorkflowOutboundInterceptor_Expecter) RequestCancelExternalWorkflow(ctx interface{}, workflowID interface{}, runID interface{}) *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call {
	return &WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call{Call: _e.mock.On("RequestCancelExternalWorkflow", ctx, workflowID, runID)}
}

func (_c *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call) Run(run func(ctx internal.Context, workflowID string, runID string)) *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call) RunAndReturn(run func(ctx internal.Context, workflowID string, runID string) internal.Future) *WorkflowOutboundInterceptor_RequestCancelExternalWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// RequestCancelNexusOperation provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) RequestCancelNexusOperation(ctx internal.Context, input internal.RequestCancelNexusOperationInput) {
	_mock.Called(ctx, input)
	return
}

// WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestCancelNexusOperation'
type WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call struct {
	*mock.Call
}

// RequestCancelNexusOperation is a helper method to define mock.On call
//   - ctx internal.Context
//   - input internal.RequestCancelNexusOperationInput
func (_e *WorkflowOutboundInterceptor_Expecter) RequestCancelNexusOperation(ctx interface{}, input interface{}) *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call {
	return &WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call{Call: _e.mock.On("RequestCancelNexusOperation", ctx, input)}
}

func (_c *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call) Run(run func(ctx internal.Context, input internal.RequestCancelNexusOperationInput)) *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 internal.RequestCancelNexusOperationInput
		if args[1] != nil {
			arg1 = args[1].(internal.RequestCancelNexusOperationInput)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call) Return() *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call {
	_c.Call.Return()
	return _c
}

func (_c *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call) RunAndReturn(run func(ctx internal.Context, input internal.RequestCancelNexusOperationInput)) *WorkflowOutboundInterceptor_RequestCancelNexusOperation_Call {
	_c.Run(run)
	return _c
}

// SetQueryHandler provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SetQueryHandler(ctx internal.Context, queryType string, handler interface{}) error {
	ret := _mock.Called(ctx, queryType, handler)

	if len(ret) == 0 {
		panic("no return value specified for SetQueryHandler")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, interface{}) error); ok {
		r0 = returnFunc(ctx, queryType, handler)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_SetQueryHandler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetQueryHandler'
type WorkflowOutboundInterceptor_SetQueryHandler_Call struct {
	*mock.Call
}

// SetQueryHandler is a helper method to define mock.On call
//   - ctx internal.Context
//   - queryType string
//   - handler interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) SetQueryHandler(ctx interface{}, queryType interface{}, handler interface{}) *WorkflowOutboundInterceptor_SetQueryHandler_Call {
	return &WorkflowOutboundInterceptor_SetQueryHandler_Call{Call: _e.mock.On("SetQueryHandler", ctx, queryType, handler)}
}

func (_c *WorkflowOutboundInterceptor_SetQueryHandler_Call) Run(run func(ctx internal.Context, queryType string, handler interface{})) *WorkflowOutboundInterceptor_SetQueryHandler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SetQueryHandler_Call) Return(err error) *WorkflowOutboundInterceptor_SetQueryHandler_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SetQueryHandler_Call) RunAndReturn(run func(ctx internal.Context, queryType string, handler interface{}) error) *WorkflowOutboundInterceptor_SetQueryHandler_Call {
	_c.Call.Return(run)
	return _c
}

// SetQueryHandlerWithOptions provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SetQueryHandlerWithOptions(ctx internal.Context, queryType string, handler interface{}, options internal.QueryHandlerOptions) error {
	ret := _mock.Called(ctx, queryType, handler, options)

	if len(ret) == 0 {
		panic("no return value specified for SetQueryHandlerWithOptions")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, interface{}, internal.QueryHandlerOptions) error); ok {
		r0 = returnFunc(ctx, queryType, handler, options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetQueryHandlerWithOptions'
type WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call struct {
	*mock.Call
}

// SetQueryHandlerWithOptions is a helper method to define mock.On call
//   - ctx internal.Context
//   - queryType string
//   - handler interface{}
//   - options internal.QueryHandlerOptions
func (_e *WorkflowOutboundInterceptor_Expecter) SetQueryHandlerWithOptions(ctx interface{}, queryType interface{}, handler interface{}, options interface{}) *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call {
	return &WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call{Call: _e.mock.On("SetQueryHandlerWithOptions", ctx, queryType, handler, options)}
}

func (_c *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call) Run(run func(ctx internal.Context, queryType string, handler interface{}, options internal.QueryHandlerOptions)) *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		var arg3 internal.QueryHandlerOptions
		if args[3] != nil {
			arg3 = args[3].(internal.QueryHandlerOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call) Return(err error) *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call) RunAndReturn(run func(ctx internal.Context, queryType string, handler interface{}, options internal.QueryHandlerOptions) error) *WorkflowOutboundInterceptor_SetQueryHandlerWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// SetUpdateHandler provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SetUpdateHandler(ctx internal.Context, updateName string, handler interface{}, opts internal.UpdateHandlerOptions) error {
	ret := _mock.Called(ctx, updateName, handler, opts)

	if len(ret) == 0 {
		panic("no return value specified for SetUpdateHandler")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, interface{}, internal.UpdateHandlerOptions) error); ok {
		r0 = returnFunc(ctx, updateName, handler, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_SetUpdateHandler_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUpdateHandler'
type WorkflowOutboundInterceptor_SetUpdateHandler_Call struct {
	*mock.Call
}

// SetUpdateHandler is a helper method to define mock.On call
//   - ctx internal.Context
//   - updateName string
//   - handler interface{}
//   - opts internal.UpdateHandlerOptions
func (_e *WorkflowOutboundInterceptor_Expecter) SetUpdateHandler(ctx interface{}, updateName interface{}, handler interface{}, opts interface{}) *WorkflowOutboundInterceptor_SetUpdateHandler_Call {
	return &WorkflowOutboundInterceptor_SetUpdateHandler_Call{Call: _e.mock.On("SetUpdateHandler", ctx, updateName, handler, opts)}
}

func (_c *WorkflowOutboundInterceptor_SetUpdateHandler_Call) Run(run func(ctx internal.Context, updateName string, handler interface{}, opts internal.UpdateHandlerOptions)) *WorkflowOutboundInterceptor_SetUpdateHandler_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		var arg3 internal.UpdateHandlerOptions
		if args[3] != nil {
			arg3 = args[3].(internal.UpdateHandlerOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SetUpdateHandler_Call) Return(err error) *WorkflowOutboundInterceptor_SetUpdateHandler_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SetUpdateHandler_Call) RunAndReturn(run func(ctx internal.Context, updateName string, handler interface{}, opts internal.UpdateHandlerOptions) error) *WorkflowOutboundInterceptor_SetUpdateHandler_Call {
	_c.Call.Return(run)
	return _c
}

// SideEffect provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SideEffect(ctx internal.Context, f func(ctx internal.Context) interface{}) converter.EncodedValue {
	ret := _mock.Called(ctx, f)

	if len(ret) == 0 {
		panic("no return value specified for SideEffect")
	}

	var r0 converter.EncodedValue
	if returnFunc, ok := ret.Get(0).(func(internal.Context, func(ctx internal.Context) interface{}) converter.EncodedValue); ok {
		r0 = returnFunc(ctx, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(converter.EncodedValue)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_SideEffect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SideEffect'
type WorkflowOutboundInterceptor_SideEffect_Call struct {
	*mock.Call
}

// SideEffect is a helper method to define mock.On call
//   - ctx internal.Context
//   - f func(ctx internal.Context) interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) SideEffect(ctx interface{}, f interface{}) *WorkflowOutboundInterceptor_SideEffect_Call {
	return &WorkflowOutboundInterceptor_SideEffect_Call{Call: _e.mock.On("SideEffect", ctx, f)}
}

func (_c *WorkflowOutboundInterceptor_SideEffect_Call) Run(run func(ctx internal.Context, f func(ctx internal.Context) interface{})) *WorkflowOutboundInterceptor_SideEffect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 func(ctx internal.Context) interface{}
		if args[1] != nil {
			arg1 = args[1].(func(ctx internal.Context) interface{})
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SideEffect_Call) Return(encodedValue converter.EncodedValue) *WorkflowOutboundInterceptor_SideEffect_Call {
	_c.Call.Return(encodedValue)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SideEffect_Call) RunAndReturn(run func(ctx internal.Context, f func(ctx internal.Context) interface{}) converter.EncodedValue) *WorkflowOutboundInterceptor_SideEffect_Call {
	_c.Call.Return(run)
	return _c
}

// SideEffectWithOptions provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SideEffectWithOptions(ctx internal.Context, options internal.SideEffectOptions, f func(ctx internal.Context) interface{}) converter.EncodedValue {
	ret := _mock.Called(ctx, options, f)

	if len(ret) == 0 {
		panic("no return value specified for SideEffectWithOptions")
	}

	var r0 converter.EncodedValue
	if returnFunc, ok := ret.Get(0).(func(internal.Context, internal.SideEffectOptions, func(ctx internal.Context) interface{}) converter.EncodedValue); ok {
		r0 = returnFunc(ctx, options, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(converter.EncodedValue)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_SideEffectWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SideEffectWithOptions'
type WorkflowOutboundInterceptor_SideEffectWithOptions_Call struct {
	*mock.Call
}

// SideEffectWithOptions is a helper method to define mock.On call
//   - ctx internal.Context
//   - options internal.SideEffectOptions
//   - f func(ctx internal.Context) interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) SideEffectWithOptions(ctx interface{}, options interface{}, f interface{}) *WorkflowOutboundInterceptor_SideEffectWithOptions_Call {
	return &WorkflowOutboundInterceptor_SideEffectWithOptions_Call{Call: _e.mock.On("SideEffectWithOptions", ctx, options, f)}
}

func (_c *WorkflowOutboundInterceptor_SideEffectWithOptions_Call) Run(run func(ctx internal.Context, options internal.SideEffectOptions, f func(ctx internal.Context) interface{})) *WorkflowOutboundInterceptor_SideEffectWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 internal.SideEffectOptions
		if args[1] != nil {
			arg1 = args[1].(internal.SideEffectOptions)
		}
		var arg2 func(ctx internal.Context) interface{}
		if args[2] != nil {
			arg2 = args[2].(func(ctx internal.Context) interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SideEffectWithOptions_Call) Return(encodedValue converter.EncodedValue) *WorkflowOutboundInterceptor_SideEffectWithOptions_Call {
	_c.Call.Return(encodedValue)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SideEffectWithOptions_Call) RunAndReturn(run func(ctx internal.Context, options internal.SideEffectOptions, f func(ctx internal.Context) interface{}) converter.EncodedValue) *WorkflowOutboundInterceptor_SideEffectWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// SignalChildWorkflow provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SignalChildWorkflow(ctx internal.Context, workflowID string, signalName string, arg interface{}) internal.Future {
	ret := _mock.Called(ctx, workflowID, signalName, arg)

	if len(ret) == 0 {
		panic("no return value specified for SignalChildWorkflow")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, string, interface{}) internal.Future); ok {
		r0 = returnFunc(ctx, workflowID, signalName, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_SignalChildWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignalChildWorkflow'
type WorkflowOutboundInterceptor_SignalChildWorkflow_Call struct {
	*mock.Call
}

// SignalChildWorkflow is a helper method to define mock.On call
//   - ctx internal.Context
//   - workflowID string
//   - signalName string
//   - arg interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) SignalChildWorkflow(ctx interface{}, workflowID interface{}, signalName interface{}, arg interface{}) *WorkflowOutboundInterceptor_SignalChildWorkflow_Call {
	return &WorkflowOutboundInterceptor_SignalChildWorkflow_Call{Call: _e.mock.On("SignalChildWorkflow", ctx, workflowID, signalName, arg)}
}

func (_c *WorkflowOutboundInterceptor_SignalChildWorkflow_Call) Run(run func(ctx internal.Context, workflowID string, signalName string, arg interface{})) *WorkflowOutboundInterceptor_SignalChildWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 interface{}
		if args[3] != nil {
			arg3 = args[3].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SignalChildWorkflow_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_SignalChildWorkflow_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SignalChildWorkflow_Call) RunAndReturn(run func(ctx internal.Context, workflowID string, signalName string, arg interface{}) internal.Future) *WorkflowOutboundInterceptor_SignalChildWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// SignalExternalWorkflow provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) SignalExternalWorkflow(ctx internal.Context, workflowID string, runID string, signalName string, arg interface{}) internal.Future {
	ret := _mock.Called(ctx, workflowID, runID, signalName, arg)

	if len(ret) == 0 {
		panic("no return value specified for SignalExternalWorkflow")
	}

	var r0 internal.Future
	if returnFunc, ok := ret.Get(0).(func(internal.Context, string, string, string, interface{}) internal.Future); ok {
		r0 = returnFunc(ctx, workflowID, runID, signalName, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Future)
		}
	}
	return r0
}

// WorkflowOutboundInterceptor_SignalExternalWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignalExternalWorkflow'
type WorkflowOutboundInterceptor_SignalExternalWorkflow_Call struct {
	*mock.Call
}

// SignalExternalWorkflow is a helper method to define mock.On call
//   - ctx internal.Context
//   - workflowID string
//   - runID string
//   - signalName string
//   - arg interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) SignalExternalWorkflow(ctx interface{}, workflowID interface{}, runID interface{}, signalName interface{}, arg interface{}) *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call {
	return &WorkflowOutboundInterceptor_SignalExternalWorkflow_Call{Call: _e.mock.On("SignalExternalWorkflow", ctx, workflowID, runID, signalName, arg)}
}

func (_c *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call) Run(run func(ctx internal.Context, workflowID string, runID string, signalName string, arg interface{})) *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 interface{}
		if args[4] != nil {
			arg4 = args[4].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call) Return(future internal.Future) *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call {
	_c.Call.Return(future)
	return _c
}

func (_c *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call) RunAndReturn(run func(ctx internal.Context, workflowID string, runID string, signalName string, arg interface{}) internal.Future) *WorkflowOutboundInterceptor_SignalExternalWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// Sleep provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) Sleep(ctx internal.Context, d time.Duration) error {
	ret := _mock.Called(ctx, d)

	if len(ret) == 0 {
		panic("no return value specified for Sleep")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, time.Duration) error); ok {
		r0 = returnFunc(ctx, d)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_Sleep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sleep'
type WorkflowOutboundInterceptor_Sleep_Call struct {
	*mock.Call
}

// Sleep is a helper method to define mock.On call
//   - ctx internal.Context
//   - d time.Duration
func (_e *WorkflowOutboundInterceptor_Expecter) Sleep(ctx interface{}, d interface{}) *WorkflowOutboundInterceptor_Sleep_Call {
	return &WorkflowOutboundInterceptor_Sleep_Call{Call: _e.mock.On("Sleep", ctx, d)}
}

func (_c *WorkflowOutboundInterceptor_Sleep_Call) Run(run func(ctx internal.Context, d time.Duration)) *WorkflowOutboundInterceptor_Sleep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_Sleep_Call) Return(err error) *WorkflowOutboundInterceptor_Sleep_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_Sleep_Call) RunAndReturn(run func(ctx internal.Context, d time.Duration) error) *WorkflowOutboundInterceptor_Sleep_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertMemo provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) UpsertMemo(ctx internal.Context, memo map[string]interface{}) error {
	ret := _mock.Called(ctx, memo)

	if len(ret) == 0 {
		panic("no return value specified for UpsertMemo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, map[string]interface{}) error); ok {
		r0 = returnFunc(ctx, memo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_UpsertMemo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertMemo'
type WorkflowOutboundInterceptor_UpsertMemo_Call struct {
	*mock.Call
}

// UpsertMemo is a helper method to define mock.On call
//   - ctx internal.Context
//   - memo map[string]interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) UpsertMemo(ctx interface{}, memo interface{}) *WorkflowOutboundInterceptor_UpsertMemo_Call {
	return &WorkflowOutboundInterceptor_UpsertMemo_Call{Call: _e.mock.On("UpsertMemo", ctx, memo)}
}

func (_c *WorkflowOutboundInterceptor_UpsertMemo_Call) Run(run func(ctx internal.Context, memo map[string]interface{})) *WorkflowOutboundInterceptor_UpsertMemo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 map[string]interface{}
		if args[1] != nil {
			arg1 = args[1].(map[string]interface{})
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_UpsertMemo_Call) Return(err error) *WorkflowOutboundInterceptor_UpsertMemo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_UpsertMemo_Call) RunAndReturn(run func(ctx internal.Context, memo map[string]interface{}) error) *WorkflowOutboundInterceptor_UpsertMemo_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertSearchAttributes provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) UpsertSearchAttributes(ctx internal.Context, attributes map[string]interface{}) error {
	ret := _mock.Called(ctx, attributes)

	if len(ret) == 0 {
		panic("no return value specified for UpsertSearchAttributes")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, map[string]interface{}) error); ok {
		r0 = returnFunc(ctx, attributes)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_UpsertSearchAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertSearchAttributes'
type WorkflowOutboundInterceptor_UpsertSearchAttributes_Call struct {
	*mock.Call
}

// UpsertSearchAttributes is a helper method to define mock.On call
//   - ctx internal.Context
//   - attributes map[string]interface{}
func (_e *WorkflowOutboundInterceptor_Expecter) UpsertSearchAttributes(ctx interface{}, attributes interface{}) *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call {
	return &WorkflowOutboundInterceptor_UpsertSearchAttributes_Call{Call: _e.mock.On("UpsertSearchAttributes", ctx, attributes)}
}

func (_c *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call) Run(run func(ctx internal.Context, attributes map[string]interface{})) *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 map[string]interface{}
		if args[1] != nil {
			arg1 = args[1].(map[string]interface{})
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call) Return(err error) *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call) RunAndReturn(run func(ctx internal.Context, attributes map[string]interface{}) error) *WorkflowOutboundInterceptor_UpsertSearchAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertTypedSearchAttributes provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) UpsertTypedSearchAttributes(ctx internal.Context, attributes ...internal.SearchAttributeUpdate) error {
	var tmpRet mock.Arguments
	if len(attributes) > 0 {
		tmpRet = _mock.Called(ctx, attributes)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UpsertTypedSearchAttributes")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(internal.Context, ...internal.SearchAttributeUpdate) error); ok {
		r0 = returnFunc(ctx, attributes...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertTypedSearchAttributes'
type WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call struct {
	*mock.Call
}

// UpsertTypedSearchAttributes is a helper method to define mock.On call
//   - ctx internal.Context
//   - attributes ...internal.SearchAttributeUpdate
func (_e *WorkflowOutboundInterceptor_Expecter) UpsertTypedSearchAttributes(ctx interface{}, attributes ...interface{}) *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call {
	return &WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call{Call: _e.mock.On("UpsertTypedSearchAttributes",
		append([]interface{}{ctx}, attributes...)...)}
}

func (_c *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call) Run(run func(ctx internal.Context, attributes ...internal.SearchAttributeUpdate)) *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 internal.Context
		if args[0] != nil {
			arg0 = args[0].(internal.Context)
		}
		var arg1 []internal.SearchAttributeUpdate
		var variadicArgs []internal.SearchAttributeUpdate
		if len(args) > 1 {
			variadicArgs = args[1].([]internal.SearchAttributeUpdate)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call) Return(err error) *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call) RunAndReturn(run func(ctx internal.Context, attributes ...internal.SearchAttributeUpdate) error) *WorkflowOutboundInterceptor_UpsertTypedSearchAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// mustEmbedWorkflowOutboundInterceptorBase provides a mock function for the type WorkflowOutboundInterceptor
func (_mock *WorkflowOutboundInterceptor) mustEmbedWorkflowOutboundInterceptorBase() {
	_mock.Called()
	return
}

// WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mustEmbedWorkflowOutboundInterceptorBase'
type WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call struct {
	*mock.Call
}

// mustEmbedWorkflowOutboundInterceptorBase is a helper method to define mock.On call
func (_e *WorkflowOutboundInterceptor_Expecter) mustEmbedWorkflowOutboundInterceptorBase() *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call {
	return &WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call{Call: _e.mock.On("mustEmbedWorkflowOutboundInterceptorBase")}
}

func (_c *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call) Run(run func()) *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call) Return() *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call {
	_c.Call.Return()
	return _c
}

func (_c *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call) RunAndReturn(run func()) *WorkflowOutboundInterceptor_mustEmbedWorkflowOutboundInterceptorBase_Call {
	_c.Run(run)
	return _c
}
