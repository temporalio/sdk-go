// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	mock "github.com/stretchr/testify/mock"
	"go.temporal.io/sdk/interceptor"
	"go.temporal.io/sdk/log"
)

// NewTracer creates a new instance of Tracer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTracer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Tracer {
	mock := &Tracer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Tracer is an autogenerated mock type for the Tracer type
type Tracer struct {
	mock.Mock
}

type Tracer_Expecter struct {
	mock *mock.Mock
}

func (_m *Tracer) EXPECT() *Tracer_Expecter {
	return &Tracer_Expecter{mock: &_m.Mock}
}

// ContextWithSpan provides a mock function for the type Tracer
func (_mock *Tracer) ContextWithSpan(context1 context.Context, tracerSpan interceptor.TracerSpan) context.Context {
	ret := _mock.Called(context1, tracerSpan)

	if len(ret) == 0 {
		panic("no return value specified for ContextWithSpan")
	}

	var r0 context.Context
	if returnFunc, ok := ret.Get(0).(func(context.Context, interceptor.TracerSpan) context.Context); ok {
		r0 = returnFunc(context1, tracerSpan)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}
	return r0
}

// Tracer_ContextWithSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContextWithSpan'
type Tracer_ContextWithSpan_Call struct {
	*mock.Call
}

// ContextWithSpan is a helper method to define mock.On call
//   - context1 context.Context
//   - tracerSpan interceptor.TracerSpan
func (_e *Tracer_Expecter) ContextWithSpan(context1 interface{}, tracerSpan interface{}) *Tracer_ContextWithSpan_Call {
	return &Tracer_ContextWithSpan_Call{Call: _e.mock.On("ContextWithSpan", context1, tracerSpan)}
}

func (_c *Tracer_ContextWithSpan_Call) Run(run func(context1 context.Context, tracerSpan interceptor.TracerSpan)) *Tracer_ContextWithSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 interceptor.TracerSpan
		if args[1] != nil {
			arg1 = args[1].(interceptor.TracerSpan)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Tracer_ContextWithSpan_Call) Return(context11 context.Context) *Tracer_ContextWithSpan_Call {
	_c.Call.Return(context11)
	return _c
}

func (_c *Tracer_ContextWithSpan_Call) RunAndReturn(run func(context1 context.Context, tracerSpan interceptor.TracerSpan) context.Context) *Tracer_ContextWithSpan_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogger provides a mock function for the type Tracer
func (_mock *Tracer) GetLogger(logger log.Logger, tracerSpanRef interceptor.TracerSpanRef) log.Logger {
	ret := _mock.Called(logger, tracerSpanRef)

	if len(ret) == 0 {
		panic("no return value specified for GetLogger")
	}

	var r0 log.Logger
	if returnFunc, ok := ret.Get(0).(func(log.Logger, interceptor.TracerSpanRef) log.Logger); ok {
		r0 = returnFunc(logger, tracerSpanRef)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(log.Logger)
		}
	}
	return r0
}

// Tracer_GetLogger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogger'
type Tracer_GetLogger_Call struct {
	*mock.Call
}

// GetLogger is a helper method to define mock.On call
//   - logger log.Logger
//   - tracerSpanRef interceptor.TracerSpanRef
func (_e *Tracer_Expecter) GetLogger(logger interface{}, tracerSpanRef interface{}) *Tracer_GetLogger_Call {
	return &Tracer_GetLogger_Call{Call: _e.mock.On("GetLogger", logger, tracerSpanRef)}
}

func (_c *Tracer_GetLogger_Call) Run(run func(logger log.Logger, tracerSpanRef interceptor.TracerSpanRef)) *Tracer_GetLogger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 log.Logger
		if args[0] != nil {
			arg0 = args[0].(log.Logger)
		}
		var arg1 interceptor.TracerSpanRef
		if args[1] != nil {
			arg1 = args[1].(interceptor.TracerSpanRef)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Tracer_GetLogger_Call) Return(logger1 log.Logger) *Tracer_GetLogger_Call {
	_c.Call.Return(logger1)
	return _c
}

func (_c *Tracer_GetLogger_Call) RunAndReturn(run func(logger log.Logger, tracerSpanRef interceptor.TracerSpanRef) log.Logger) *Tracer_GetLogger_Call {
	_c.Call.Return(run)
	return _c
}

// MarshalSpan provides a mock function for the type Tracer
func (_mock *Tracer) MarshalSpan(tracerSpan interceptor.TracerSpan) (map[string]string, error) {
	ret := _mock.Called(tracerSpan)

	if len(ret) == 0 {
		panic("no return value specified for MarshalSpan")
	}

	var r0 map[string]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(interceptor.TracerSpan) (map[string]string, error)); ok {
		return returnFunc(tracerSpan)
	}
	if returnFunc, ok := ret.Get(0).(func(interceptor.TracerSpan) map[string]string); ok {
		r0 = returnFunc(tracerSpan)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(interceptor.TracerSpan) error); ok {
		r1 = returnFunc(tracerSpan)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Tracer_MarshalSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalSpan'
type Tracer_MarshalSpan_Call struct {
	*mock.Call
}

// MarshalSpan is a helper method to define mock.On call
//   - tracerSpan interceptor.TracerSpan
func (_e *Tracer_Expecter) MarshalSpan(tracerSpan interface{}) *Tracer_MarshalSpan_Call {
	return &Tracer_MarshalSpan_Call{Call: _e.mock.On("MarshalSpan", tracerSpan)}
}

func (_c *Tracer_MarshalSpan_Call) Run(run func(tracerSpan interceptor.TracerSpan)) *Tracer_MarshalSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 interceptor.TracerSpan
		if args[0] != nil {
			arg0 = args[0].(interceptor.TracerSpan)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tracer_MarshalSpan_Call) Return(stringToString map[string]string, err error) *Tracer_MarshalSpan_Call {
	_c.Call.Return(stringToString, err)
	return _c
}

func (_c *Tracer_MarshalSpan_Call) RunAndReturn(run func(tracerSpan interceptor.TracerSpan) (map[string]string, error)) *Tracer_MarshalSpan_Call {
	_c.Call.Return(run)
	return _c
}

// Options provides a mock function for the type Tracer
func (_mock *Tracer) Options() interceptor.TracerOptions {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 interceptor.TracerOptions
	if returnFunc, ok := ret.Get(0).(func() interceptor.TracerOptions); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(interceptor.TracerOptions)
	}
	return r0
}

// Tracer_Options_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Options'
type Tracer_Options_Call struct {
	*mock.Call
}

// Options is a helper method to define mock.On call
func (_e *Tracer_Expecter) Options() *Tracer_Options_Call {
	return &Tracer_Options_Call{Call: _e.mock.On("Options")}
}

func (_c *Tracer_Options_Call) Run(run func()) *Tracer_Options_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Tracer_Options_Call) Return(tracerOptions interceptor.TracerOptions) *Tracer_Options_Call {
	_c.Call.Return(tracerOptions)
	return _c
}

func (_c *Tracer_Options_Call) RunAndReturn(run func() interceptor.TracerOptions) *Tracer_Options_Call {
	_c.Call.Return(run)
	return _c
}

// SpanFromContext provides a mock function for the type Tracer
func (_mock *Tracer) SpanFromContext(context1 context.Context) interceptor.TracerSpan {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for SpanFromContext")
	}

	var r0 interceptor.TracerSpan
	if returnFunc, ok := ret.Get(0).(func(context.Context) interceptor.TracerSpan); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interceptor.TracerSpan)
		}
	}
	return r0
}

// Tracer_SpanFromContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpanFromContext'
type Tracer_SpanFromContext_Call struct {
	*mock.Call
}

// SpanFromContext is a helper method to define mock.On call
//   - context1 context.Context
func (_e *Tracer_Expecter) SpanFromContext(context1 interface{}) *Tracer_SpanFromContext_Call {
	return &Tracer_SpanFromContext_Call{Call: _e.mock.On("SpanFromContext", context1)}
}

func (_c *Tracer_SpanFromContext_Call) Run(run func(context1 context.Context)) *Tracer_SpanFromContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tracer_SpanFromContext_Call) Return(tracerSpan interceptor.TracerSpan) *Tracer_SpanFromContext_Call {
	_c.Call.Return(tracerSpan)
	return _c
}

func (_c *Tracer_SpanFromContext_Call) RunAndReturn(run func(context1 context.Context) interceptor.TracerSpan) *Tracer_SpanFromContext_Call {
	_c.Call.Return(run)
	return _c
}

// SpanName provides a mock function for the type Tracer
func (_mock *Tracer) SpanName(options *interceptor.TracerStartSpanOptions) string {
	ret := _mock.Called(options)

	if len(ret) == 0 {
		panic("no return value specified for SpanName")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(*interceptor.TracerStartSpanOptions) string); ok {
		r0 = returnFunc(options)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Tracer_SpanName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SpanName'
type Tracer_SpanName_Call struct {
	*mock.Call
}

// SpanName is a helper method to define mock.On call
//   - options *interceptor.TracerStartSpanOptions
func (_e *Tracer_Expecter) SpanName(options interface{}) *Tracer_SpanName_Call {
	return &Tracer_SpanName_Call{Call: _e.mock.On("SpanName", options)}
}

func (_c *Tracer_SpanName_Call) Run(run func(options *interceptor.TracerStartSpanOptions)) *Tracer_SpanName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *interceptor.TracerStartSpanOptions
		if args[0] != nil {
			arg0 = args[0].(*interceptor.TracerStartSpanOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tracer_SpanName_Call) Return(s string) *Tracer_SpanName_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Tracer_SpanName_Call) RunAndReturn(run func(options *interceptor.TracerStartSpanOptions) string) *Tracer_SpanName_Call {
	_c.Call.Return(run)
	return _c
}

// StartSpan provides a mock function for the type Tracer
func (_mock *Tracer) StartSpan(tracerStartSpanOptions *interceptor.TracerStartSpanOptions) (interceptor.TracerSpan, error) {
	ret := _mock.Called(tracerStartSpanOptions)

	if len(ret) == 0 {
		panic("no return value specified for StartSpan")
	}

	var r0 interceptor.TracerSpan
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*interceptor.TracerStartSpanOptions) (interceptor.TracerSpan, error)); ok {
		return returnFunc(tracerStartSpanOptions)
	}
	if returnFunc, ok := ret.Get(0).(func(*interceptor.TracerStartSpanOptions) interceptor.TracerSpan); ok {
		r0 = returnFunc(tracerStartSpanOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interceptor.TracerSpan)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*interceptor.TracerStartSpanOptions) error); ok {
		r1 = returnFunc(tracerStartSpanOptions)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Tracer_StartSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartSpan'
type Tracer_StartSpan_Call struct {
	*mock.Call
}

// StartSpan is a helper method to define mock.On call
//   - tracerStartSpanOptions *interceptor.TracerStartSpanOptions
func (_e *Tracer_Expecter) StartSpan(tracerStartSpanOptions interface{}) *Tracer_StartSpan_Call {
	return &Tracer_StartSpan_Call{Call: _e.mock.On("StartSpan", tracerStartSpanOptions)}
}

func (_c *Tracer_StartSpan_Call) Run(run func(tracerStartSpanOptions *interceptor.TracerStartSpanOptions)) *Tracer_StartSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *interceptor.TracerStartSpanOptions
		if args[0] != nil {
			arg0 = args[0].(*interceptor.TracerStartSpanOptions)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tracer_StartSpan_Call) Return(tracerSpan interceptor.TracerSpan, err error) *Tracer_StartSpan_Call {
	_c.Call.Return(tracerSpan, err)
	return _c
}

func (_c *Tracer_StartSpan_Call) RunAndReturn(run func(tracerStartSpanOptions *interceptor.TracerStartSpanOptions) (interceptor.TracerSpan, error)) *Tracer_StartSpan_Call {
	_c.Call.Return(run)
	return _c
}

// UnmarshalSpan provides a mock function for the type Tracer
func (_mock *Tracer) UnmarshalSpan(stringToString map[string]string) (interceptor.TracerSpanRef, error) {
	ret := _mock.Called(stringToString)

	if len(ret) == 0 {
		panic("no return value specified for UnmarshalSpan")
	}

	var r0 interceptor.TracerSpanRef
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(map[string]string) (interceptor.TracerSpanRef, error)); ok {
		return returnFunc(stringToString)
	}
	if returnFunc, ok := ret.Get(0).(func(map[string]string) interceptor.TracerSpanRef); ok {
		r0 = returnFunc(stringToString)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interceptor.TracerSpanRef)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(map[string]string) error); ok {
		r1 = returnFunc(stringToString)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Tracer_UnmarshalSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnmarshalSpan'
type Tracer_UnmarshalSpan_Call struct {
	*mock.Call
}

// UnmarshalSpan is a helper method to define mock.On call
//   - stringToString map[string]string
func (_e *Tracer_Expecter) UnmarshalSpan(stringToString interface{}) *Tracer_UnmarshalSpan_Call {
	return &Tracer_UnmarshalSpan_Call{Call: _e.mock.On("UnmarshalSpan", stringToString)}
}

func (_c *Tracer_UnmarshalSpan_Call) Run(run func(stringToString map[string]string)) *Tracer_UnmarshalSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[string]string
		if args[0] != nil {
			arg0 = args[0].(map[string]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tracer_UnmarshalSpan_Call) Return(tracerSpanRef interceptor.TracerSpanRef, err error) *Tracer_UnmarshalSpan_Call {
	_c.Call.Return(tracerSpanRef, err)
	return _c
}

func (_c *Tracer_UnmarshalSpan_Call) RunAndReturn(run func(stringToString map[string]string) (interceptor.TracerSpanRef, error)) *Tracer_UnmarshalSpan_Call {
	_c.Call.Return(run)
	return _c
}

// mustEmbedBaseTracer provides a mock function for the type Tracer
func (_mock *Tracer) mustEmbedBaseTracer() {
	_mock.Called()
	return
}

// Tracer_mustEmbedBaseTracer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'mustEmbedBaseTracer'
type Tracer_mustEmbedBaseTracer_Call struct {
	*mock.Call
}

// mustEmbedBaseTracer is a helper method to define mock.On call
func (_e *Tracer_Expecter) mustEmbedBaseTracer() *Tracer_mustEmbedBaseTracer_Call {
	return &Tracer_mustEmbedBaseTracer_Call{Call: _e.mock.On("mustEmbedBaseTracer")}
}

func (_c *Tracer_mustEmbedBaseTracer_Call) Run(run func()) *Tracer_mustEmbedBaseTracer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Tracer_mustEmbedBaseTracer_Call) Return() *Tracer_mustEmbedBaseTracer_Call {
	_c.Call.Return()
	return _c
}

func (_c *Tracer_mustEmbedBaseTracer_Call) RunAndReturn(run func()) *Tracer_mustEmbedBaseTracer_Call {
	_c.Run(run)
	return _c
}
